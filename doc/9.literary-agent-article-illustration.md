# 文学创作 Agent - 文章配图功能设计

**文档版本**：v1.0  
**创建日期**：2026-01-08  
**最后更新**：2026-01-08  
**功能状态**：已落地

---

## 1. 功能概述

文章配图功能是文学创作 Agent 的核心能力之一，旨在为文章自动生成配图提示词标记，并批量生成配图，最终导出带图片的完整文章。

### 1.1 核心价值

- **自动化配图**：AI 自动识别文章中需要配图的位置，并生成配图提示词
- **批量生成**：一键生成所有配图，无需逐张手动操作
- **状态可恢复**：浏览器刷新后能恢复到正确阶段，不会丢失进度
- **修改即清后续**：任何"提交型修改"都会清空后续阶段数据，避免脏数据
- **禁止跳未来**：用户不能跳转到未生成过的阶段，确保工作流完整性

### 1.2 用户场景

> 作为内容创作者，我希望上传一篇文章后，AI 能自动标注需要配图的位置并生成配图提示词，然后一键生成所有配图并导出成品。

---

## 2. 工作流设计

### 2.1 阶段定义

文章配图工作流包含 5 个阶段：

| 阶段 | 阶段标识 | 说明 | 可跳转条件 |
|------|----------|------|-----------|
| 上传 | `upload` | 上传文章文件（.md/.txt） | 总是可跳转 |
| 预览 | `editing` | 预览文章内容，选择提示词模板 | 已上传文章 |
| 配图标记 | `markersGenerated` | AI 生成带 `[插图]: 描述` 标记的文章 | 已生成标记 |
| 生图中 | `imagesGenerating` | 逐条解析标记并调用生图模型 | 已生成标记（自动进入） |
| 导出 | `imagesGenerated` | 所有配图生成完成，可导出 | 所有配图已完成 |

### 2.2 状态机规则

#### 规则 1：单项可随时查看已生成过的任意阶段

- 服务端 `ArticleIllustrationWorkflow` 记录当前 phase/version/markers/images 进度
- 前端刷新后以服务端 workflow.phase 为准恢复阶段
- 浏览器与服务器状态始终一致

#### 规则 2：提交型修改后清空并重置后续阶段

**提交型修改触发点**：

1. **文章更新**（重新上传/修改文章内容）：
   - `version++`
   - 清空标记/图片/旧配图资产
   - phase 回到 `editing`
   - 快照当前 workflow 到历史（debug-only，最多保留 10 条）

2. **标记生成成功**（AI 生成配图标记完成）：
   - `version++`
   - 写入 markers
   - 清空旧配图资产
   - phase 进入 `markersGenerated`
   - 快照当前 workflow 到历史

#### 规则 3：只切换阶段不修改：不重算、不丢后续数据

- 用户点击阶段按钮切换时，只同步本地展示，不触发后端写入
- 服务端数据保持不变，后续阶段数据不会丢失

#### 规则 4：禁止跳转到未来阶段（未生成过的）

- 前端 `jumpToPhase` 基于服务端 workflow.phase 判断目标阶段是否"未来"
- 若目标阶段顺序 > 服务端当前阶段顺序，弹窗提示并禁止跳转

### 2.3 状态机流转图

```
                                   ┌─────────────┐
                                   │   upload    │
                                   │  （上传）    │
                                   └──────┬──────┘
                                          │ 上传文章
                                          v
                                   ┌─────────────┐
                                   │   editing   │
                                   │  （预览）    │
                                   └──────┬──────┘
                                          │ 生成配图标记
                                          v
                                   ┌─────────────┐
                                   │ markersGen  │
                                   │ （配图标记） │
                                   └──────┬──────┘
                                          │ 开始生图
                                          v
                                   ┌─────────────┐
                                   │ imagesGen   │
                                   │ （生图中）   │
                                   └──────┬──────┘
                                          │ 全部完成
                                          v
                                   ┌─────────────┐
                                   │ imagesGen   │
                                   │ （导出）     │
                                   └─────────────┘

注：任何"提交型修改"都会触发 version++，并清空后续阶段数据
```

---

## 3. 数据模型

### 3.1 ArticleIllustrationWorkflow（服务端状态机）

| 字段 | 类型 | 说明 |
|------|------|------|
| `version` | int | 版本号，每次提交型修改递增 |
| `phase` | string | 当前阶段：`upload/editing/markersGenerated/imagesGenerating/imagesGenerated` |
| `markers` | array | 标记列表：`[{ index, text }]` |
| `expectedImageCount` | int? | 预期图片数（一般等于 markers.length） |
| `doneImageCount` | int | 已生成图片数 |
| `assetIdByMarkerIndex` | object | 已完成图片映射：`{ "0": "assetId1", "1": "assetId2" }` |
| `updatedAt` | datetime | 最后更新时间 |

### 3.2 ImageMasterWorkspace（工作区）

| 字段 | 类型 | 说明 |
|------|------|------|
| `id` | string | 工作区唯一标识（Guid） |
| `title` | string | 工作区标题 |
| `scenarioType` | string | 场景类型：`article`（文章配图） |
| `articleContent` | string | 原始文章内容（Markdown） |
| `articleContentWithMarkers` | string | 带配图标记的文章内容（AI 生成） |
| `articleWorkflow` | object | 当前工作流状态 |
| `articleWorkflowHistory` | array | 历史工作流状态（debug-only，最多保留 10 条） |
| `memberUserIds` | array | 成员用户 ID 列表 |
| `coverAssetId` | string | 封面图资产 ID |
| `createdAt` | datetime | 创建时间 |
| `updatedAt` | datetime | 最后更新时间 |

### 3.3 ImageAsset（图片资产）

| 字段 | 类型 | 说明 |
|------|------|------|
| `id` | string | 资产唯一标识（Guid） |
| `workspaceId` | string | 所属工作区 ID |
| `url` | string | 图片 URL（CDN 或 COS） |
| `sha256` | string | 文件 SHA256 哈希（用于去重） |
| `width` | int | 图片宽度 |
| `height` | int | 图片高度 |
| `prompt` | string | 生图提示词 |
| `articleInsertionIndex` | int? | 文章配图场景：该图片在文章中的插入位置索引（0-based） |
| `originalMarkerText` | string | 文章配图场景：原始标记文本（如"温馨的咖啡厅场景"） |
| `createdAt` | datetime | 创建时间 |

---

## 4. 接口设计

### 4.1 生成配图标记接口

**接口路径**：`POST /api/v1/admin/image-master/workspaces/{id}/article/generate-markers`

**请求参数**：

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| `articleContent` | string | 是 | 原始文章内容（Markdown） |
| `userInstruction` | string | 是 | 用户选择的提示词模板（作为 system prompt） |

**响应格式**：SSE 流式

| 事件类型 | 数据结构 | 说明 |
|----------|----------|------|
| `delta` | `{ type: "delta", text: string }` | 流式输出生成的带标记文章 |
| `done` | `{ type: "done", fullText: string }` | 生成完成，返回完整带标记文章 |
| `error` | `{ type: "error", message: string }` | 生成失败 |

**服务端行为**（提交型修改）：
- 成功完成后：`version++`，写入 `articleContentWithMarkers`，提取并保存 `markers`，清空旧配图资产，phase 切换到 `markersGenerated`
- 快照当前 workflow 到历史（debug-only，最多保留 10 条）

### 4.2 上传配图资产接口

**接口路径**：`POST /api/v1/admin/image-master/workspaces/{id}/assets`

**请求参数**：

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| `data` | string | 二选一 | base64 或 dataURL 格式图片 |
| `sourceUrl` | string | 二选一 | 外部图片 URL（HTTPS） |
| `prompt` | string | 否 | 生图提示词（用于记录） |
| `width` | int | 否 | 图片宽度 |
| `height` | int | 否 | 图片高度 |
| `articleInsertionIndex` | int | 否 | 文章配图场景：该图片在文章中的插入位置索引（0-based） |
| `originalMarkerText` | string | 否 | 文章配图场景：原始标记文本（如"温馨的咖啡厅场景"） |

**响应格式**：

```json
{
  "success": true,
  "data": {
    "asset": {
      "id": "abc123",
      "url": "https://...",
      "sha256": "...",
      "articleInsertionIndex": 0,
      "originalMarkerText": "温馨的咖啡厅场景"
    }
  }
}
```

**服务端行为**（推进 workflow）：
- 若携带 `articleInsertionIndex`：
  - 删除旧的同 index 配图（若存在）
  - 写入新 asset 的 `ArticleInsertionIndex/OriginalMarkerText`
  - 更新 workflow：`assetIdByMarkerIndex[index] = assetId`，`doneImageCount++`
  - 若 `doneImageCount >= expectedImageCount`，自动切换 phase 到 `imagesGenerated`

### 4.3 导出文章接口

**接口路径**：`POST /api/v1/admin/image-master/workspaces/{id}/article/export`

**请求参数**：

| 参数 | 类型 | 必填 | 说明 |
|------|------|------|------|
| `useCdn` | bool | 是 | 是否使用 CDN 图片链接（false 则下载图片到本地） |
| `exportFormat` | string | 否 | 导出格式，默认 `markdown` |

**响应格式**：

```json
{
  "success": true,
  "data": {
    "content": "# 文章标题\n\n![配图1](https://...)...",
    "format": "markdown",
    "assetCount": 3
  }
}
```

**服务端行为**：
- 按 `articleInsertionIndex` 顺序读取配图资产
- 将文章中的 `[插图]: 描述` 标记替换为 `![描述](url)`
- 返回替换后的完整文章内容

---

## 5. 前端实现

### 5.1 核心组件

**ArticleIllustrationEditorPage**：文章配图编辑器主页面

- 位置：`prd-admin/src/pages/literary-agent/ArticleIllustrationEditorPage.tsx`
- 职责：
  - 管理本地 UI 状态（phase/articleContent/markers/markerRunItems）
  - 与后端服务交互（loadWorkspace/updateWorkspace/generateMarkers/uploadAsset/exportArticle）
  - 基于服务端 workflow 控制阶段跳转禁用
  - 处理配图生成进度与错误重试

### 5.2 状态管理

**本地状态**（React state）：

| 状态 | 类型 | 说明 |
|------|------|------|
| `phase` | string | 当前阶段（初始化时从服务端 workflow 同步） |
| `articleContent` | string | 原始文章内容 |
| `articleWithMarkers` | string | 带标记的文章内容 |
| `markers` | array | 标记列表 |
| `markerRunItems` | array | 配图生成进度列表 |
| `workspace` | object | 工作区详情（包含 articleWorkflow） |

**同步策略**：

- 页面加载时：调用 `loadWorkspace`，从服务端 `workspace.articleWorkflow` 恢复 phase/markers
- 提交型修改后：刷新 workspace detail，同步最新 workflow
- 阶段跳转前：先刷新 workspace detail，基于服务端 workflow.phase 判断是否允许跳转

### 5.3 关键交互流程

#### 5.3.1 上传文章

```typescript
// 用户上传文章文件
const handleUploadArticle = async (file: File) => {
  const content = await file.text();
  await updateImageMasterWorkspace({
    id: workspaceId,
    articleContent: content, // 触发后端 version++，清空标记/图片
    idempotencyKey: crypto.randomUUID(),
  });
  await loadWorkspace(); // 刷新 workspace，同步最新 workflow
};
```

#### 5.3.2 生成配图标记

```typescript
// 用户点击"生成配图标记"
const handleGenerateMarkers = async () => {
  const stream = generateArticleMarkers({
    workspaceId,
    articleContent,
    userInstruction: selectedPrompt,
  });

  // SSE 流式接收
  for await (const chunk of stream) {
    if (chunk.type === 'delta') {
      setArticleWithMarkers((prev) => prev + chunk.text);
    } else if (chunk.type === 'done') {
      setArticleWithMarkers(chunk.fullText);
      await loadWorkspace(); // 刷新 workspace，同步最新 workflow
    }
  }
};
```

#### 5.3.3 一键生图

```typescript
// 用户点击"一键生图"
const handleGenerateAllImages = async () => {
  for (const [idx, marker] of markers.entries()) {
    // 1. 解析标记为结构化 prompt
    const plan = await planImageGen({ prompt: marker.text });

    // 2. 创建生图 run
    const run = await createImageGenRun({ ...plan });

    // 3. SSE 订阅生图结果
    const stream = streamImageGenRunWithRetry(run.id);
    for await (const chunk of stream) {
      if (chunk.type === 'completed') {
        // 4. 上传图片到 workspace
        await uploadImageMasterWorkspaceAsset({
          workspaceId,
          data: chunk.imageData,
          articleInsertionIndex: idx, // 关键：写入插入位置索引
          originalMarkerText: marker.text,
        });
      }
    }
  }

  await loadWorkspace(); // 刷新 workspace，同步最新 workflow
};
```

#### 5.3.4 阶段跳转

```typescript
// 用户点击阶段按钮
const jumpToPhase = async (targetPhase: string) => {
  // 先刷新 workspace detail，获取最新 workflow
  const { workspace: latest } = await getImageMasterWorkspaceDetail(workspaceId);
  const serverPhase = latest.articleWorkflow.phase;

  // 判断目标阶段是否"未来"
  const phaseOrder = ['upload', 'editing', 'markersGenerated', 'imagesGenerating', 'imagesGenerated'];
  const serverOrder = phaseOrder.indexOf(serverPhase);
  const targetOrder = phaseOrder.indexOf(targetPhase);

  if (targetOrder > serverOrder) {
    // 禁止跳转到未来阶段
    alert('该阶段尚未生成，无法跳转');
    return;
  }

  // 允许跳转，只更新本地 UI 状态（不触发后端写入）
  setPhase(targetPhase);
};
```

---

## 6. 后端实现

### 6.1 核心服务

**AdminImageMasterController**：管理后台 ImageMaster 接口

- 位置：`prd-api/src/PrdAgent.Api/Controllers/Admin/AdminImageMasterController.cs`
- 职责：
  - 处理文章配图相关接口（生成标记/上传资产/导出文章）
  - 维护 ArticleWorkflow 状态机（version/phase/markers/images）
  - 实现"提交型修改清后续"逻辑
  - 快照历史 workflow（debug-only）

### 6.2 关键逻辑

#### 6.2.1 提交型修改：文章更新

```csharp
[HttpPut("{id}")]
public async Task<IActionResult> UpdateWorkspace(string id, [FromBody] UpdateWorkspaceRequest req)
{
    var ws = await _workspaceRepo.GetByIdAsync(id);
    if (ws == null) return NotFound();

    // 检测是否修改了 articleContent
    var articleChanged = !string.IsNullOrEmpty(req.ArticleContent) 
                         && req.ArticleContent != ws.ArticleContent;

    if (articleChanged)
    {
        // 提交型修改：version++，清空后续阶段
        ws.ArticleWorkflow.Version++;
        ws.ArticleWorkflow.Phase = "editing";
        ws.ArticleWorkflow.Markers.Clear();
        ws.ArticleWorkflow.ExpectedImageCount = null;
        ws.ArticleWorkflow.DoneImageCount = 0;
        ws.ArticleWorkflow.AssetIdByMarkerIndex.Clear();
        ws.ArticleWorkflow.UpdatedAt = DateTime.UtcNow;

        // 快照当前 workflow 到历史（debug-only，最多保留 10 条）
        ws.ArticleWorkflowHistory.Add(ws.ArticleWorkflow.Clone());
        if (ws.ArticleWorkflowHistory.Count > 10)
        {
            ws.ArticleWorkflowHistory.RemoveAt(0);
        }

        // 删除旧的文章配图资产
        var oldAssets = await _assetRepo.GetByWorkspaceIdAsync(id);
        foreach (var asset in oldAssets.Where(a => a.ArticleInsertionIndex != null))
        {
            await _assetRepo.DeleteAsync(asset.Id);
        }

        ws.ArticleContent = req.ArticleContent;
    }

    await _workspaceRepo.UpdateAsync(ws);
    return Ok(new { workspace = ws });
}
```

#### 6.2.2 提交型修改：标记生成成功

```csharp
[HttpPost("{id}/article/generate-markers")]
public async Task<IActionResult> GenerateArticleMarkers(string id, [FromBody] GenerateMarkersRequest req)
{
    var ws = await _workspaceRepo.GetByIdAsync(id);
    if (ws == null) return NotFound();

    // SSE 流式生成（省略 LLM 调用细节）
    var fullText = await StreamGenerateMarkersAsync(req.ArticleContent, req.UserInstruction);

    // 提取标记：[插图]: 描述
    var markers = ExtractMarkers(fullText);

    // 提交型修改：version++，写入 markers，清空旧配图资产
    ws.ArticleWorkflow.Version++;
    ws.ArticleWorkflow.Phase = "markersGenerated";
    ws.ArticleWorkflow.Markers = markers;
    ws.ArticleWorkflow.ExpectedImageCount = markers.Count;
    ws.ArticleWorkflow.DoneImageCount = 0;
    ws.ArticleWorkflow.AssetIdByMarkerIndex.Clear();
    ws.ArticleWorkflow.UpdatedAt = DateTime.UtcNow;

    // 快照当前 workflow 到历史
    ws.ArticleWorkflowHistory.Add(ws.ArticleWorkflow.Clone());
    if (ws.ArticleWorkflowHistory.Count > 10)
    {
        ws.ArticleWorkflowHistory.RemoveAt(0);
    }

    // 删除旧的文章配图资产
    var oldAssets = await _assetRepo.GetByWorkspaceIdAsync(id);
    foreach (var asset in oldAssets.Where(a => a.ArticleInsertionIndex != null))
    {
        await _assetRepo.DeleteAsync(asset.Id);
    }

    ws.ArticleContentWithMarkers = fullText;
    await _workspaceRepo.UpdateAsync(ws);

    return Ok(new { fullText, markers });
}
```

#### 6.2.3 推进 workflow：上传配图资产

```csharp
[HttpPost("{id}/assets")]
public async Task<IActionResult> UploadWorkspaceAsset(string id, [FromBody] UploadAssetRequest req)
{
    var ws = await _workspaceRepo.GetByIdAsync(id);
    if (ws == null) return NotFound();

    // 若携带 articleInsertionIndex，删除旧的同 index 配图
    if (req.ArticleInsertionIndex.HasValue)
    {
        var oldAssets = await _assetRepo.GetByWorkspaceIdAsync(id);
        var oldAsset = oldAssets.FirstOrDefault(a => a.ArticleInsertionIndex == req.ArticleInsertionIndex);
        if (oldAsset != null)
        {
            // 检查 SHA256 是否相同，避免误删底层文件
            if (oldAsset.Sha256 != newAsset.Sha256)
            {
                await _assetRepo.DeleteAsync(oldAsset.Id);
            }
        }
    }

    // 写入新 asset
    var asset = new ImageAsset
    {
        Id = Guid.NewGuid().ToString(),
        WorkspaceId = id,
        Url = uploadedUrl,
        Sha256 = sha256,
        ArticleInsertionIndex = req.ArticleInsertionIndex,
        OriginalMarkerText = req.OriginalMarkerText,
        CreatedAt = DateTime.UtcNow,
    };
    await _assetRepo.CreateAsync(asset);

    // 推进 workflow 进度
    if (req.ArticleInsertionIndex.HasValue)
    {
        var idx = req.ArticleInsertionIndex.Value;
        ws.ArticleWorkflow.AssetIdByMarkerIndex[idx.ToString()] = asset.Id;
        ws.ArticleWorkflow.DoneImageCount = ws.ArticleWorkflow.AssetIdByMarkerIndex.Count;
        ws.ArticleWorkflow.UpdatedAt = DateTime.UtcNow;

        // 若全部完成，自动切换到 imagesGenerated
        if (ws.ArticleWorkflow.DoneImageCount >= ws.ArticleWorkflow.ExpectedImageCount)
        {
            ws.ArticleWorkflow.Phase = "imagesGenerated";
        }
        else
        {
            ws.ArticleWorkflow.Phase = "imagesGenerating";
        }

        await _workspaceRepo.UpdateAsync(ws);
    }

    return Ok(new { asset });
}
```

#### 6.2.4 导出文章

```csharp
[HttpPost("{id}/article/export")]
public async Task<IActionResult> ExportArticle(string id, [FromBody] ExportArticleRequest req)
{
    var ws = await _workspaceRepo.GetByIdAsync(id);
    if (ws == null) return NotFound();

    var content = ws.ArticleContentWithMarkers;
    var assets = await _assetRepo.GetByWorkspaceIdAsync(id);

    // 按 articleInsertionIndex 排序
    var sortedAssets = assets
        .Where(a => a.ArticleInsertionIndex.HasValue)
        .OrderBy(a => a.ArticleInsertionIndex)
        .ToList();

    // 替换标记为图片链接
    foreach (var asset in sortedAssets)
    {
        var marker = $"[插图]: {asset.OriginalMarkerText}";
        var replacement = $"![{asset.OriginalMarkerText}]({asset.Url})";
        content = content.Replace(marker, replacement);
    }

    return Ok(new { content, format = "markdown", assetCount = sortedAssets.Count });
}
```

### 6.3 BSON 映射配置

**BsonClassMapRegistration**：确保 MongoDB 字段名为 camelCase

- 位置：`prd-api/src/PrdAgent.Infrastructure/Database/BsonClassMapRegistration.cs`
- 配置：

```csharp
BsonClassMap.RegisterClassMap<ArticleIllustrationWorkflow>(cm =>
{
    cm.AutoMap();
    cm.SetIgnoreExtraElements(true);
});

BsonClassMap.RegisterClassMap<ArticleIllustrationMarker>(cm =>
{
    cm.AutoMap();
    cm.SetIgnoreExtraElements(true);
});

BsonClassMap.RegisterClassMap<ImageMasterWorkspace>(cm =>
{
    cm.AutoMap();
    cm.MapMember(x => x.ArticleWorkflow).SetElementName("articleWorkflow");
    cm.MapMember(x => x.ArticleWorkflowHistory).SetElementName("articleWorkflowHistory");
    cm.SetIgnoreExtraElements(true);
});
```

---

## 7. 验收标准

### 7.1 功能验收

- [ ] 支持上传 .md/.txt 文章文件
- [ ] 可创建/编辑/删除提示词模板
- [ ] 生成配图标记时必须选择提示词模板
- [ ] AI 生成的标记格式为 `[插图]: 描述`
- [ ] 可逐条编辑标记并重新生成单张配图
- [ ] 一键生图按顺序生成所有配图
- [ ] 生成失败的配图可单独重试
- [ ] 刷新页面后能恢复到正确阶段
- [ ] 不能跳转到未生成过的阶段（弹窗提示）
- [ ] 重新上传文章会清空标记/图片
- [ ] 重新生成标记会清空旧图片
- [ ] 导出时可选择 CDN 链接或本地下载
- [ ] 导出的 Markdown 包含所有配图

### 7.2 状态机验收

- [ ] 浏览器刷新后 phase 与服务端一致
- [ ] 文章更新后 version++，标记/图片清空
- [ ] 标记生成成功后 version++，旧配图资产清空
- [ ] 只切换阶段不修改时，后续数据不丢失
- [ ] 禁止跳转到未来阶段（弹窗提示）
- [ ] 历史 workflow 最多保留 10 条（debug-only）

### 7.3 边界情况验收

- [ ] 同 index 配图重新生成时，旧配图被删除
- [ ] 新旧配图 SHA256 相同时，不删除底层文件
- [ ] 所有配图生成完成后，自动切换到 `imagesGenerated`
- [ ] 导出时按 `articleInsertionIndex` 顺序替换标记

---

## 8. 未来优化方向

### 8.1 功能增强

- [ ] 支持导出 HTML/PDF 格式
- [ ] 支持批量编辑标记（批量修改提示词）
- [ ] 支持配图预览与对比（多张候选图）
- [ ] 支持配图样式模板（统一风格）

### 8.2 性能优化

- [ ] 配图生成并发控制（避免同时生成过多图片）
- [ ] 配图缓存（相同提示词复用已生成图片）
- [ ] 增量导出（只导出变更部分）

### 8.3 用户体验

- [ ] 配图生成进度可视化（进度条/百分比）
- [ ] 配图生成失败时自动重试（指数退避）
- [ ] 配图生成时间预估（基于历史数据）

---

## 9. 参考文档

- [PRD Agent 产品需求文档](3.prd.md) - 第 4.8 节
- [PRD Agent 软件需求规格说明书](2.srs.md) - 第 5.3 节、第 7.2.10-7.2.11 节
- [Doc vs Code 差异清单](8.doc-code-diff.md) - 第 2.2 节
- [文档维护与反向更新规则](0.doc-maintenance.md)

---

## 附录：实现清单

### A.1 前端改动

| 文件 | 改动内容 |
|------|----------|
| `prd-admin/src/services/contracts/imageMaster.ts` | 新增 `articleWorkflow/articleWorkflowHistory` 字段 |
| `prd-admin/src/services/real/imageMaster.ts` | 修复 `updateImageMasterWorkspaceReal` 不传 `articleContent` 的 bug |
| `prd-admin/src/pages/literary-agent/ArticleIllustrationEditorPage.tsx` | 基于服务端 workflow 控制阶段跳转，上传配图时附带 `articleInsertionIndex` |

### A.2 后端改动

| 文件 | 改动内容 |
|------|----------|
| `PrdAgent.Core/Models/ArticleIllustrationWorkflow.cs` | 新增 workflow 数据模型 |
| `PrdAgent.Core/Models/ImageMasterWorkspace.cs` | 新增 `ArticleWorkflow/ArticleWorkflowHistory` 字段 |
| `PrdAgent.Core/Models/ImageAsset.cs` | 新增 `ArticleInsertionIndex/OriginalMarkerText` 字段 |
| `PrdAgent.Infrastructure/Database/BsonClassMapRegistration.cs` | 注册 workflow 的 BSON 映射（camelCase） |
| `PrdAgent.Api/Controllers/Admin/AdminImageMasterController.cs` | 实现"提交型修改清后续"逻辑，推进 workflow 进度 |

### A.3 文档改动

| 文件 | 改动内容 |
|------|----------|
| `doc/3.prd.md` | 新增第 4.8 节"文学创作 Agent（文章配图）" |
| `doc/2.srs.md` | 新增第 5.3 节"文学创作 Agent 接口"，第 7.2.10-7.2.11 节数据模型 |
| `doc/8.doc-code-diff.md` | 更新第 2.2 节，标注"文学创作 Agent 已落地" |
| `doc/9.literary-agent-article-illustration.md` | 新增本文档（完整设计说明） |
