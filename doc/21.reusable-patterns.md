# 可复用模式文档 (Reusable Patterns)

> 从实际开发中沉淀的第三方工具型组件模式，可直接复用到其他模块。

---

## 1. 软删除 + 回收站模式 (Soft Delete + Trash)

### 1.1 问题场景

- 用户误删数据后无法恢复
- 需要保留删除历史用于审计
- 需要提供"回收站"功能让用户恢复数据

### 1.2 模型设计

```csharp
// 在实体模型中添加以下字段
public class YourEntity
{
    // ... 其他字段 ...

    /// <summary>是否已删除（软删除）</summary>
    public bool IsDeleted { get; set; } = false;

    /// <summary>删除时间</summary>
    public DateTime? DeletedAt { get; set; }

    /// <summary>删除人 UserId</summary>
    public string? DeletedBy { get; set; }
}
```

### 1.3 后端 API 设计

```
DELETE /{entities}/{id}           → 软删除（移入回收站）
GET    /{entities}/trash          → 回收站列表
POST   /{entities}/{id}/restore   → 从回收站恢复
DELETE /{entities}/{id}/permanent → 永久删除（彻底删除）
```

### 1.4 控制器实现模板

```csharp
/// <summary>软删除</summary>
[HttpDelete("{id}")]
public async Task<IActionResult> Delete(string id, CancellationToken ct)
{
    var entity = await _db.Entities.Find(x => x.Id == id).FirstOrDefaultAsync(ct);
    if (entity == null)
        return NotFound(ApiResponse<object>.Fail(ErrorCodes.DOCUMENT_NOT_FOUND, "记录不存在"));

    // 权限检查
    if (!HasPermission(entity))
        return StatusCode(403, ApiResponse<object>.Fail(ErrorCodes.PERMISSION_DENIED, "无权限"));

    if (entity.IsDeleted)
        return BadRequest(ApiResponse<object>.Fail(ErrorCodes.INVALID_FORMAT, "已在回收站中"));

    // 软删除
    var update = Builders<YourEntity>.Update
        .Set(x => x.IsDeleted, true)
        .Set(x => x.DeletedAt, DateTime.UtcNow)
        .Set(x => x.DeletedBy, GetUserId());

    await _db.Entities.UpdateOneAsync(x => x.Id == id, update, cancellationToken: ct);
    return Ok(ApiResponse<object>.Ok(new { deleted = true }));
}

/// <summary>回收站列表</summary>
[HttpGet("trash")]
public async Task<IActionResult> ListDeleted([FromQuery] int page = 1, [FromQuery] int pageSize = 20, CancellationToken ct = default)
{
    var filter = Builders<YourEntity>.Filter.Eq(x => x.IsDeleted, true);
    // 加入权限过滤...

    var total = await _db.Entities.CountDocumentsAsync(filter, cancellationToken: ct);
    var items = await _db.Entities
        .Find(filter)
        .SortByDescending(x => x.DeletedAt)
        .Skip((page - 1) * pageSize)
        .Limit(pageSize)
        .ToListAsync(ct);

    return Ok(ApiResponse<object>.Ok(new { items, total, page, pageSize }));
}

/// <summary>恢复</summary>
[HttpPost("{id}/restore")]
public async Task<IActionResult> Restore(string id, CancellationToken ct)
{
    var entity = await _db.Entities.Find(x => x.Id == id).FirstOrDefaultAsync(ct);
    if (entity == null)
        return NotFound(ApiResponse<object>.Fail(ErrorCodes.DOCUMENT_NOT_FOUND, "记录不存在"));

    if (!entity.IsDeleted)
        return BadRequest(ApiResponse<object>.Fail(ErrorCodes.INVALID_FORMAT, "不在回收站中"));

    var update = Builders<YourEntity>.Update
        .Set(x => x.IsDeleted, false)
        .Set(x => x.DeletedAt, (DateTime?)null)
        .Set(x => x.DeletedBy, (string?)null)
        .Set(x => x.UpdatedAt, DateTime.UtcNow);

    await _db.Entities.UpdateOneAsync(x => x.Id == id, update, cancellationToken: ct);
    return Ok(ApiResponse<object>.Ok(new { restored = true }));
}

/// <summary>永久删除</summary>
[HttpDelete("{id}/permanent")]
public async Task<IActionResult> PermanentDelete(string id, CancellationToken ct)
{
    var entity = await _db.Entities.Find(x => x.Id == id).FirstOrDefaultAsync(ct);
    if (entity == null)
        return NotFound(ApiResponse<object>.Fail(ErrorCodes.DOCUMENT_NOT_FOUND, "记录不存在"));

    if (!entity.IsDeleted)
        return BadRequest(ApiResponse<object>.Fail(ErrorCodes.INVALID_FORMAT, "只能永久删除回收站中的记录"));

    // 删除关联数据...
    await _db.Entities.DeleteOneAsync(x => x.Id == id, ct);
    return Ok(ApiResponse<object>.Ok(new { deleted = true }));
}
```

### 1.5 列表查询时排除已删除

```csharp
// 在所有列表查询中默认排除已删除记录
var filters = new List<FilterDefinition<YourEntity>>();
filters.Add(filterBuilder.Eq(x => x.IsDeleted, false));
```

### 1.6 前端 Contract

```typescript
// 软删除相关字段
interface YourEntity {
  // ... 其他字段 ...
  isDeleted?: boolean;
  deletedAt?: string;
  deletedBy?: string;
}

// 回收站 API
type ListDeletedContract = (input?: { limit?: number; offset?: number }) =>
  Promise<ApiResponse<{ items: YourEntity[]; total: number }>>;

type RestoreContract = (input: { id: string }) =>
  Promise<ApiResponse<{ entity: YourEntity }>>;

type PermanentDeleteContract = (input: { id: string }) =>
  Promise<ApiResponse<{ deleted: boolean }>>;
```

---

## 2. 文件夹组织模式 (Folder Organization)

### 2.1 问题场景

- 数据量增长后需要分类管理
- 用户需要自定义分组方式
- 需要支持拖拽移动

### 2.2 模型设计

```csharp
/// <summary>文件夹模型</summary>
public class Folder
{
    public string Id { get; set; } = Guid.NewGuid().ToString("N");
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    public string? Color { get; set; }      // 显示颜色，如 #FF5500
    public string? Icon { get; set; }       // 图标名称
    public int SortOrder { get; set; } = 0; // 排序权重
    public string? SpaceId { get; set; }    // 空间隔离（预留）
    public string CreatedBy { get; set; } = string.Empty;
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
}

/// <summary>在实体模型中添加 FolderId</summary>
public class YourEntity
{
    // ... 其他字段 ...

    /// <summary>所属文件夹 ID（null 表示未分类/根目录）</summary>
    public string? FolderId { get; set; }
}
```

### 2.3 后端 API 设计

```
# 文件夹 CRUD
GET    /folders              → 文件夹列表
POST   /folders              → 创建文件夹
PUT    /folders/{id}         → 更新文件夹
DELETE /folders/{id}         → 删除文件夹（内容移到根目录）

# 移动实体
POST   /{entities}/{id}/move      → 移动单个实体到文件夹
POST   /{entities}/batch-move     → 批量移动

# 列表查询支持 folderId 筛选
GET    /{entities}?folderId=xxx   → 特定文件夹
GET    /{entities}?folderId=root  → 根目录（未分类）
```

### 2.4 控制器实现模板

```csharp
/// <summary>文件夹列表</summary>
[HttpGet("folders")]
public async Task<IActionResult> ListFolders(CancellationToken ct)
{
    var items = await _db.Folders
        .Find(x => x.SpaceId == null || x.SpaceId == "default")
        .SortByDescending(x => x.SortOrder)
        .ThenBy(x => x.Name)
        .ToListAsync(ct);

    return Ok(ApiResponse<object>.Ok(new { items }));
}

/// <summary>创建文件夹</summary>
[HttpPost("folders")]
public async Task<IActionResult> CreateFolder([FromBody] CreateFolderRequest request, CancellationToken ct)
{
    if (string.IsNullOrWhiteSpace(request.Name))
        return BadRequest(ApiResponse<object>.Fail(ErrorCodes.INVALID_FORMAT, "名称不能为空"));

    // 检查同名
    var exists = await _db.Folders.Find(x => x.Name == request.Name.Trim()).AnyAsync(ct);
    if (exists)
        return BadRequest(ApiResponse<object>.Fail(ErrorCodes.DUPLICATE, "已存在同名文件夹"));

    var folder = new Folder
    {
        Name = request.Name.Trim(),
        Description = request.Description?.Trim(),
        Color = request.Color,
        Icon = request.Icon,
        SortOrder = request.SortOrder,
        CreatedBy = GetUserId()
    };

    await _db.Folders.InsertOneAsync(folder, cancellationToken: ct);
    return Ok(ApiResponse<object>.Ok(new { folder }));
}

/// <summary>删除文件夹（内容移到根目录）</summary>
[HttpDelete("folders/{id}")]
public async Task<IActionResult> DeleteFolder(string id, CancellationToken ct)
{
    var folder = await _db.Folders.Find(x => x.Id == id).FirstOrDefaultAsync(ct);
    if (folder == null)
        return NotFound(ApiResponse<object>.Fail(ErrorCodes.DOCUMENT_NOT_FOUND, "文件夹不存在"));

    // 将文件夹内的实体移到根目录
    var update = Builders<YourEntity>.Update
        .Set(x => x.FolderId, (string?)null)
        .Set(x => x.UpdatedAt, DateTime.UtcNow);
    await _db.Entities.UpdateManyAsync(x => x.FolderId == id, update, cancellationToken: ct);

    // 删除文件夹
    await _db.Folders.DeleteOneAsync(x => x.Id == id, ct);
    return Ok(ApiResponse<object>.Ok(new { deleted = true }));
}

/// <summary>移动实体到文件夹</summary>
[HttpPost("{id}/move")]
public async Task<IActionResult> MoveToFolder(string id, [FromBody] MoveRequest request, CancellationToken ct)
{
    var entity = await _db.Entities.Find(x => x.Id == id).FirstOrDefaultAsync(ct);
    if (entity == null)
        return NotFound(ApiResponse<object>.Fail(ErrorCodes.DOCUMENT_NOT_FOUND, "记录不存在"));

    // 验证目标文件夹存在
    if (!string.IsNullOrEmpty(request.FolderId))
    {
        var folderExists = await _db.Folders.Find(x => x.Id == request.FolderId).AnyAsync(ct);
        if (!folderExists)
            return BadRequest(ApiResponse<object>.Fail(ErrorCodes.DOCUMENT_NOT_FOUND, "目标文件夹不存在"));
    }

    entity.FolderId = string.IsNullOrEmpty(request.FolderId) ? null : request.FolderId;
    entity.UpdatedAt = DateTime.UtcNow;

    await _db.Entities.ReplaceOneAsync(x => x.Id == id, entity, cancellationToken: ct);
    return Ok(ApiResponse<object>.Ok(new { entity }));
}

/// <summary>列表查询支持 folderId 筛选</summary>
[HttpGet]
public async Task<IActionResult> List([FromQuery] string? folderId, ...)
{
    // ...
    if (!string.IsNullOrWhiteSpace(folderId))
    {
        if (folderId == "root")
            filters.Add(filterBuilder.Eq(x => x.FolderId, (string?)null));
        else
            filters.Add(filterBuilder.Eq(x => x.FolderId, folderId));
    }
    // ...
}
```

### 2.5 前端 Contract

```typescript
interface Folder {
  id: string;
  name: string;
  description?: string;
  color?: string;
  icon?: string;
  sortOrder: number;
  spaceId?: string;
  createdBy: string;
  createdAt: string;
  updatedAt: string;
}

interface YourEntity {
  // ...
  folderId?: string;
}

// 文件夹 API
type ListFoldersContract = () => Promise<ApiResponse<{ items: Folder[] }>>;

type CreateFolderContract = (input: {
  name: string;
  description?: string;
  color?: string;
  icon?: string;
  sortOrder?: number;
}) => Promise<ApiResponse<{ folder: Folder }>>;

type UpdateFolderContract = (input: {
  id: string;
  name?: string;
  description?: string;
  color?: string;
  icon?: string;
  sortOrder?: number;
}) => Promise<ApiResponse<{ folder: Folder }>>;

type DeleteFolderContract = (input: { id: string }) => Promise<ApiResponse<{ deleted: boolean }>>;

// 移动 API
type MoveToFolderContract = (input: {
  id: string;
  folderId?: string; // null/empty = 移到根目录
}) => Promise<ApiResponse<{ entity: YourEntity }>>;

type BatchMoveContract = (input: {
  ids: string[];
  folderId?: string;
}) => Promise<ApiResponse<{ movedCount: number }>>;

// 列表支持 folderId 筛选
type ListEntitiesContract = (input?: {
  folderId?: string; // "root" = 根目录, 其他 = 指定文件夹, 空 = 全部
  // ...
}) => Promise<ApiResponse<{ items: YourEntity[]; total: number }>>;
```

---

## 3. 空间隔离模式 (Space Isolation)

### 3.1 问题场景

- 多团队/多租户数据隔离
- 防止用户访问他人数据
- 需要预留扩展能力，当前可共享

### 3.2 设计原则

```
┌─────────────────────────────────────────────────────────────────┐
│                    Space Isolation Architecture                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. 当前阶段：所有用户共享同一空间                               │
│     SpaceId = null 或 "default"                                  │
│                                                                  │
│  2. 未来扩展：每个团队独立空间                                   │
│     SpaceId = "team-xxx"                                         │
│                                                                  │
│  3. 隔离粒度：通过文件夹的 SpaceId 间接隔离                      │
│     Folder.SpaceId → Entity.FolderId                             │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 3.3 模型设计

```csharp
public class Folder
{
    // ...

    /// <summary>
    /// 空间 ID（预留，用于未来多空间支持）
    /// 默认所有人共享同一个空间，spaceId = null 或 "default"
    /// </summary>
    public string? SpaceId { get; set; }
}
```

### 3.4 访问控制逻辑

```csharp
/// <summary>检查用户是否有权访问指定空间</summary>
private bool CanAccessSpace(string? userSpaceId, string? resourceSpaceId)
{
    // 同空间允许访问
    if (userSpaceId == resourceSpaceId) return true;

    // 默认空间对所有人开放（null 和 "default" 等效）
    bool userInDefault = userSpaceId == null || userSpaceId == "default";
    bool resourceInDefault = resourceSpaceId == null || resourceSpaceId == "default";

    return userInDefault && resourceInDefault;
}

/// <summary>查询时过滤空间</summary>
private FilterDefinition<Folder> GetSpaceFilter(string? userSpaceId)
{
    var builder = Builders<Folder>.Filter;

    // 当前阶段：只返回默认空间
    return builder.Or(
        builder.Eq(x => x.SpaceId, (string?)null),
        builder.Eq(x => x.SpaceId, "default")
    );

    // 未来扩展：返回用户所属空间
    // return builder.Eq(x => x.SpaceId, userSpaceId);
}
```

### 3.5 测试用例模板

```csharp
#region Space Isolation Tests (防止空间泄漏)

[Fact]
public void SpaceIsolation_DifferentSpaces_ShouldNotBeMixed()
{
    // Arrange
    var folderA = new Folder { Name = "A团队", SpaceId = "space-a" };
    var folderB = new Folder { Name = "B团队", SpaceId = "space-b" };
    var allFolders = new List<Folder> { folderA, folderB };

    // Act
    var spaceAFolders = allFolders.Where(f => f.SpaceId == "space-a").ToList();
    var spaceBFolders = allFolders.Where(f => f.SpaceId == "space-b").ToList();

    // Assert - 确保空间隔离
    Assert.Single(spaceAFolders);
    Assert.Single(spaceBFolders);
    Assert.DoesNotContain(spaceAFolders, f => f.SpaceId == "space-b");
}

[Fact]
public void SpaceIsolation_UserCannotAccessOtherSpace_ShouldReturnEmpty()
{
    // Arrange
    var folders = new List<Folder>
    {
        new() { Name = "私有", SpaceId = "space-owner" }
    };

    // Act - 攻击者尝试访问
    var attackerFolders = folders.Where(f => f.SpaceId == "space-attacker").ToList();

    // Assert
    Assert.Empty(attackerFolders);
}

[Theory]
[InlineData("space-a", "space-a", true)]   // 同空间
[InlineData("space-a", "space-b", false)]  // 不同空间
[InlineData(null, null, true)]             // 默认空间
[InlineData(null, "default", true)]        // null 和 default 等效
public void SpaceIsolation_AccessCheck_ShouldRespectBoundaries(
    string? userSpaceId, string? resourceSpaceId, bool expectedAccess)
{
    // Act
    bool hasAccess = CanAccessSpace(userSpaceId, resourceSpaceId);

    // Assert
    Assert.Equal(expectedAccess, hasAccess);
}

#endregion
```

---

## 4. 组合使用示例

以缺陷管理 (Defect Agent) 为例，完整组合三种模式：

```
┌─────────────────────────────────────────────────────────────────┐
│                     DefectReport Model                           │
├─────────────────────────────────────────────────────────────────┤
│  基础字段:                                                       │
│    Id, DefectNo, Title, RawContent, Status, Severity...         │
│                                                                  │
│  + 软删除字段:                                                   │
│    IsDeleted, DeletedAt, DeletedBy                              │
│                                                                  │
│  + 文件夹字段:                                                   │
│    FolderId → 关联 DefectFolder                                  │
│                                                                  │
│                     DefectFolder Model                           │
├─────────────────────────────────────────────────────────────────┤
│  Id, Name, Description, Color, Icon, SortOrder                  │
│                                                                  │
│  + 空间隔离字段:                                                 │
│    SpaceId → 用于多团队隔离                                      │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

API 端点完整设计:

# 缺陷 CRUD
GET    /defects?folderId=xxx     → 按文件夹筛选（排除已删除）
POST   /defects                  → 创建
PUT    /defects/{id}             → 更新
DELETE /defects/{id}             → 软删除

# 回收站
GET    /defects/trash            → 回收站列表
POST   /defects/{id}/restore     → 恢复
DELETE /defects/{id}/permanent   → 永久删除

# 文件夹
GET    /folders                  → 列表（按空间过滤）
POST   /folders                  → 创建
PUT    /folders/{id}             → 更新
DELETE /folders/{id}             → 删除

# 移动
POST   /defects/{id}/move        → 移动到文件夹
POST   /defects/batch-move       → 批量移动
```

---

## 5. 检查清单 (Checklist)

### 添加软删除功能时：
- [ ] 模型添加 `IsDeleted`, `DeletedAt`, `DeletedBy` 字段
- [ ] 列表查询默认排除 `IsDeleted = true`
- [ ] 修改删除接口为软删除
- [ ] 添加回收站列表接口
- [ ] 添加恢复接口
- [ ] 添加永久删除接口
- [ ] 前端添加对应 Contract 和实现
- [ ] 添加单元测试

### 添加文件夹组织功能时：
- [ ] 创建 Folder 模型
- [ ] 实体模型添加 `FolderId` 字段
- [ ] 注册 MongoDB Collection
- [ ] 添加文件夹 CRUD 接口
- [ ] 添加移动/批量移动接口
- [ ] 列表查询支持 `folderId` 筛选
- [ ] 删除文件夹时处理内部实体
- [ ] 前端添加对应 Contract 和实现
- [ ] 添加单元测试

### 添加空间隔离功能时：
- [ ] Folder 模型添加 `SpaceId` 字段
- [ ] 实现访问控制逻辑
- [ ] 查询时添加空间过滤
- [ ] 添加空间隔离测试用例
- [ ] 文档说明当前阶段策略

---

*文档版本: 1.0 | 创建时间: 2026-01-27 | 基于缺陷管理 Agent 实现经验*
