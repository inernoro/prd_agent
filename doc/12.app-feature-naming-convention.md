# 应用与子功能命名规范

## 核心概念

### 应用（Application）
**定义**：一个独立的、完备的系统，对外提供完整的业务价值。在外部看来是一个独立的操作系统。

**判断标准**：
- ✅ 有独立的用户界面或 API 入口
- ✅ 提供完整的业务闭环
- ✅ 可以独立部署和运行
- ✅ 有明确的用户群体和使用场景

### 子功能（Feature）
**定义**：应用内部的具体功能点，是应用提供业务价值的具体实现。

**判断标准**：
- ✅ 隶属于某个应用
- ✅ 需要调用 LLM 模型
- ✅ 有明确的输入输出
- ✅ 可以独立配置模型

## 层级结构

```
应用（Application）
  └─ 子功能（Feature）
      └─ 模型需求（Model Requirement）
          └─ 模型分组（Model Group）
              └─ 具体模型（Model）
```

## 命名规范（约定优于配置）

### 核心格式

```
{app}.{feature}[.{subfeature}...]::modelType
```

**说明**：
- `::` 前是功能路径（可以有多层）
- `::` 后是期望的模型类型
- 功能路径使用 `.` 分隔，采用 `kebab-case`

### 应用代码（App）

**格式**：`kebab-case`（小写，短横线分隔）

**示例**：
```
desktop              # 桌面客户端
visual-agent         # 视觉创作 Agent
literary-agent       # 文学创作 Agent
open-platform        # 开放平台
admin                # 管理后台
```

### 子功能路径（Feature Path）

**格式**：`{feature}[.{subfeature}...]`（可以有多层）

**示例**：
```
chat                          # 聊天（一级）
chat.sendmessage              # 聊天.发送消息（二级）
chat.sendmessage.stream       # 聊天.发送消息.流式（三级）
prd.analysis                  # PRD.分析
image.generation              # 图片.生成
```

### 模型类型（Model Type）

**格式**：固定的模型类型标识

**支持的类型**：
```
chat                 # 对话模型
intent               # 意图识别
vision               # 视觉理解
generation           # 图片生成
code                 # 代码生成
embedding            # 向量嵌入
rerank               # 重排序
```

### 完整示例

```
desktop.chat.sendmessage::chat              # 桌面端.聊天.发送消息::对话模型
desktop.chat.sendmessage::intent            # 桌面端.聊天.发送消息::意图识别
desktop.chat::vision                        # 桌面端.聊天::视觉模型（整个聊天功能共用）
desktop.prd.analysis::chat                  # 桌面端.PRD.分析::对话模型
visual-agent.image::generation              # 视觉Agent.图片::生成模型
visual-agent.image::vision                  # 视觉Agent.图片::视觉模型
visual-agent.image::chat                    # 视觉Agent.图片::对话模型
literary-agent.content::chat                # 文学Agent.内容::对话模型
literary-agent.illustration::generation     # 文学Agent.配图::生成模型
open-platform.proxy::chat                   # 开放平台.代理::对话模型
open-platform.proxy::embedding              # 开放平台.代理::向量嵌入
admin.lab::chat                             # 管理后台.实验室::对话模型
```

### 命名规则

**层级规则**：
- 第一层（app）：应用名称，必需
- 第二层（feature）：主要功能，必需
- 第三层+（subfeature）：子功能，可选，可以有多层
- 最后（modelType）：模型类型，必需

**示例对比**：
```
✅ desktop.chat::chat                    # 简单场景：整个聊天功能用一个对话模型
✅ desktop.chat.sendmessage::chat        # 复杂场景：发送消息需要对话模型
✅ desktop.chat.sendmessage::intent      # 复杂场景：发送消息需要意图识别
✅ desktop.chat::vision                  # 整个聊天功能需要视觉模型

❌ desktop::chat                         # 缺少功能层级
❌ desktop.chat                          # 缺少模型类型
❌ Desktop.Chat::Chat                    # 使用了大写
❌ desktop_chat::chat                    # 使用了下划线
```

## 系统内应用清单

### 1. Desktop（桌面客户端）

| App Caller Key | 说明 | 模型类型 |
|---------------|------|---------|
| `desktop.chat.sendmessage::chat` | 聊天发送消息-对话 | chat |
| `desktop.chat.sendmessage::intent` | 聊天发送消息-意图识别 | intent |
| `desktop.chat::vision` | 聊天-视觉理解（整个功能共用） | vision |
| `desktop.prd.analysis::chat` | PRD分析-对话 | chat |
| `desktop.prd.preview::chat` | PRD预览问答-对话 | chat |
| `desktop.gap.detection::chat` | Gap检测-对话 | chat |
| `desktop.gap.summarization::chat` | Gap总结-对话 | chat |

**展示结构**：
```
Desktop
  ├─ Chat
  │   ├─ sendmessage
  │   │   ├─ ::chat (对话模型)
  │   │   └─ ::intent (意图识别)
  │   └─ ::vision (视觉模型)
  ├─ PRD
  │   ├─ analysis::chat
  │   └─ preview::chat
  └─ Gap
      ├─ detection::chat
      └─ summarization::chat
```

### 2. Visual Agent（视觉创作）

| App Caller Key | 说明 | 模型类型 |
|---------------|------|---------|
| `visual-agent.image::generation` | 图片生成 | generation |
| `visual-agent.image::vision` | 图片分析 | vision |
| `visual-agent.image::chat` | 创意对话 | chat |

**展示结构**：
```
Visual Agent
  └─ Image
      ├─ ::generation (生成模型)
      ├─ ::vision (视觉模型)
      └─ ::chat (对话模型)
```

### 3. Literary Agent（文学创作）

| App Caller Key | 说明 | 模型类型 |
|---------------|------|---------|
| `literary-agent.content::chat` | 内容生成 | chat |
| `literary-agent.content.polishing::chat` | 内容润色 | chat |
| `literary-agent.illustration::generation` | 配图生成 | generation |

**展示结构**：
```
Literary Agent
  ├─ Content
  │   ├─ ::chat (内容生成)
  │   └─ polishing::chat (润色)
  └─ Illustration
      └─ ::generation (配图生成)
```

### 4. Open Platform（开放平台）

| App Caller Key | 说明 | 模型类型 |
|---------------|------|---------|
| `open-platform.proxy::chat` | 聊天代理 | chat |
| `open-platform.proxy::embedding` | 向量嵌入代理 | embedding |
| `open-platform.proxy::rerank` | 重排序代理 | rerank |

**展示结构**：
```
Open Platform
  └─ Proxy
      ├─ ::chat (聊天代理)
      ├─ ::embedding (向量嵌入)
      └─ ::rerank (重排序)
```

### 5. Admin（管理后台）

| App Caller Key | 说明 | 模型类型 |
|---------------|------|---------|
| `admin.lab::chat` | 实验室-对话 | chat |
| `admin.lab::vision` | 实验室-视觉 | vision |
| `admin.lab::generation` | 实验室-生成 | generation |

**展示结构**：
```
Admin
  └─ Lab
      ├─ ::chat (对话测试)
      ├─ ::vision (视觉测试)
      └─ ::generation (生成测试)
```

## 代码中的约定

### 后端调用方式

```csharp
// 在业务代码中调用 LLM 时，必须传入完整的调用标识
var client = await _scheduler.GetClientAsync(
    appCallerCode: "prd-desktop.chat",  // 应用.子功能
    modelType: ModelTypes.Chat,
    cancellationToken: ct
);
```

### 前端调用方式

```typescript
// 前端调用 API 时，在请求头或参数中传入
const response = await fetch('/api/v1/chat/send', {
  headers: {
    'X-App-Caller': 'prd-desktop.chat',  // 应用.子功能
  },
  body: JSON.stringify({ message: '...' })
});
```

## 自动扫描原理

### 扫描机制

**原理**：从 LLM 调用日志中提取所有出现过的 `appCallerCode`，与已注册应用对比，发现未登记的。

**实现步骤**：
1. 查询 `llm_request_logs` 表，提取 distinct `app_caller_code`
2. 与 `llm_app_callers` 表对比，找出未注册的
3. 自动创建应用记录，标记为 `is_auto_registered: true`
4. 返回发现的应用列表供用户确认

**前置条件**：
- ✅ `LlmRequestLog` 模型需要添加 `AppCallerCode` 字段
- ✅ 业务代码需要改造成使用 `SmartModelScheduler`
- ✅ 所有 LLM 调用必须传入 `appCallerCode`

### 扫描的局限性

**能扫描到的**：
- ✅ 已经被调用过的子功能
- ✅ 有日志记录的子功能

**扫描不到的**：
- ❌ 新开发但未调用的子功能
- ❌ 日志被清理的历史子功能
- ❌ 代码中硬编码但未实际使用的标识

### 手动补充机制

**场景 1：新开发的子功能**
```
开发者在代码中新增了 `prd-desktop.document-export` 功能，
但还没有用户调用过，扫描无法发现。

解决方案：
1. 在管理后台点击"手动添加子功能"
2. 选择应用：prd-desktop
3. 输入子功能代码：document-export
4. 输入子功能名称：文档导出
5. 选择模型需求：chat
6. 保存
```

**场景 2：批量导入**
```
开发者可以提供一个 JSON 文件，批量导入应用和子功能：

{
  "app": "prd-desktop",
  "features": [
    {
      "code": "document-export",
      "name": "文档导出",
      "modelTypes": ["chat"]
    },
    {
      "code": "template-generation",
      "name": "模板生成",
      "modelTypes": ["chat"]
    }
  ]
}
```

**场景 3：代码注册（推荐）**
```csharp
// 在代码中使用静态常量定义，编译时检查
public static class AppCallers
{
    public static class PrdDesktop
    {
        public const string Chat = "prd-desktop.chat";
        public const string IntentRecognition = "prd-desktop.intent-recognition";
        public const string PrdAnalysis = "prd-desktop.prd-analysis";
        // ... 其他子功能
    }
}

// 使用时
var client = await _scheduler.GetClientAsync(
    appCallerCode: AppCallers.PrdDesktop.Chat,  // 类型安全
    modelType: ModelTypes.Chat,
    cancellationToken: ct
);

// 系统启动时自动注册
public static class AppCallerRegistry
{
    public static void RegisterAll()
    {
        // 通过反射扫描 AppCallers 类，自动注册所有常量
        var allCallers = typeof(AppCallers)
            .GetNestedTypes()
            .SelectMany(t => t.GetFields(BindingFlags.Public | BindingFlags.Static | BindingFlags.Constant))
            .Where(f => f.FieldType == typeof(string))
            .Select(f => (string)f.GetValue(null))
            .ToList();
        
        // 自动创建/更新应用记录
        foreach (var caller in allCallers)
        {
            // 解析 app-code.feature-code
            var parts = caller.Split('.');
            var appCode = parts[0];
            var featureCode = parts[1];
            
            // 创建或更新应用和子功能
            // ...
        }
    }
}
```

## 约定俗成的规则

### 规则 1：应用代码必须与项目名对应

| 项目/系统 | 应用代码 |
|----------|---------|
| prd-desktop（Tauri 桌面端） | `prd-desktop` |
| prd-admin（Web 管理后台） | `prd-admin` |
| prd-api（后端 API） | `prd-api` |
| 视觉创作 Agent | `visual-agent` |
| 文学创作 Agent | `literary-agent` |
| 开放平台 | `open-platform` |

### 规则 2：子功能代码必须体现业务含义

**好的命名**：
- ✅ `chat` - 清晰，聊天
- ✅ `prd-analysis` - 清晰，PRD 分析
- ✅ `image-generation` - 清晰，图片生成

**不好的命名**：
- ❌ `sendMessage` - 技术化，不体现业务
- ❌ `llmCall` - 太抽象
- ❌ `feature1` - 无意义

### 规则 3：调用标识必须在代码中定义为常量

**强制要求**：
```csharp
// ✅ 正确：使用常量
var client = await _scheduler.GetClientAsync(
    appCallerCode: AppCallers.PrdDesktop.Chat,
    modelType: ModelTypes.Chat,
    cancellationToken: ct
);

// ❌ 错误：硬编码字符串
var client = await _scheduler.GetClientAsync(
    appCallerCode: "prd-desktop.chat",  // 容易拼写错误
    modelType: ModelTypes.Chat,
    cancellationToken: ct
);
```

### 规则 4：新增子功能必须同步更新文档

**流程**：
1. 在代码中定义常量（`AppCallers.cs`）
2. 在本文档中更新应用清单表格
3. 在管理后台手动添加或等待自动扫描
4. 配置模型分组

## 检查清单

### 新增应用时

- [ ] 应用代码符合 `kebab-case` 规范
- [ ] 应用名称清晰体现业务定位
- [ ] 在本文档中添加应用清单
- [ ] 在代码中创建应用常量类
- [ ] 在管理后台初始化应用

### 新增子功能时

- [ ] 子功能代码符合 `kebab-case` 规范
- [ ] 子功能名称体现业务含义
- [ ] 在本文档中更新子功能表格
- [ ] 在代码中添加子功能常量
- [ ] 在管理后台添加子功能（手动或扫描）
- [ ] 配置模型需求和分组

## 常见问题

### Q1：如何判断是应用还是子功能？
**A**：问自己：这是一个独立的系统吗？如果是，就是应用；如果是应用内的一个功能点，就是子功能。

### Q2：子功能可以跨应用复用吗？
**A**：不可以。每个子功能必须隶属于一个应用。如果多个应用有相同的功能，应该分别定义（例如 `prd-desktop.chat` 和 `prd-admin.chat`）。

### Q3：扫描会漏掉新功能怎么办？
**A**：使用"手动添加子功能"或"批量导入"功能补充。推荐在代码中定义常量，系统启动时自动注册。

### Q4：应用代码可以修改吗？
**A**：不建议。应用代码是唯一标识，修改会导致历史数据无法关联。如果必须修改，需要同步更新所有代码和数据库。

### Q5：如何确保所有开发者遵守规范？
**A**：
1. 在代码审查中检查
2. 使用常量定义强制类型安全
3. 在 CI/CD 中添加检查脚本
4. 定期审查管理后台的应用列表

## 示例：添加新应用的完整流程

### 场景：新增"代码审查 Agent"

**步骤 1：确定应用代码**
```
应用名：Code Review Agent
应用代码：code-review-agent
```

**步骤 2：定义子功能**
```
- code-analysis：代码分析（需要 code 模型）
- bug-detection：Bug 检测（需要 code 模型）
- suggestion-generation：建议生成（需要 chat 模型）
```

**步骤 3：在代码中定义常量**
```csharp
public static class AppCallers
{
    public static class CodeReviewAgent
    {
        public const string CodeAnalysis = "code-review-agent.code-analysis";
        public const string BugDetection = "code-review-agent.bug-detection";
        public const string SuggestionGeneration = "code-review-agent.suggestion-generation";
    }
}
```

**步骤 4：更新本文档**
在"系统内应用清单"中添加：
```markdown
### 6. Code Review Agent（code-review-agent）
**定位**：独立的代码审查系统，提供代码分析、Bug 检测、建议生成的完整流程

**子功能**：
| Feature Code | 中文名 | 模型需求 | 说明 |
|-------------|--------|---------|------|
| `code-analysis` | 代码分析 | code | 分析代码结构和质量 |
| `bug-detection` | Bug 检测 | code | 检测潜在的 Bug |
| `suggestion-generation` | 建议生成 | chat | 生成改进建议 |
```

**步骤 5：在管理后台初始化**
1. 访问"模型管理" → "应用与分组"
2. 点击"初始化/同步应用"（如果已配置自动注册）
3. 或点击"手动添加应用"，填写应用信息

**步骤 6：配置模型分组**
1. 选择应用"Code Review Agent"
2. 为每个子功能配置模型分组
3. 保存配置

完成！现在可以在代码中使用 `AppCallers.CodeReviewAgent.CodeAnalysis` 调用 LLM 了。
