# 应用与子功能命名规范

## 核心概念

### 应用（Application）
**定义**：一个独立的、完备的系统，对外提供完整的业务价值。在外部看来是一个独立的操作系统。

**判断标准**：
- ✅ 有独立的用户界面或 API 入口
- ✅ 提供完整的业务闭环
- ✅ 可以独立部署和运行
- ✅ 有明确的用户群体和使用场景

### 子功能（Feature）
**定义**：应用内部的具体功能点，是应用提供业务价值的具体实现。

**判断标准**：
- ✅ 隶属于某个应用
- ✅ 需要调用 LLM 模型
- ✅ 有明确的输入输出
- ✅ 可以独立配置模型

## 层级结构

```
应用（Application）
  └─ 子功能（Feature）
      └─ 模型需求（Model Requirement）
          └─ 模型分组（Model Group）
              └─ 具体模型（Model）
```

## 命名规范

### 应用代码（App Code）

**格式**：`kebab-case`（小写，短横线分隔）

**规则**：
- 使用英文，简洁明了
- 体现应用的核心定位
- 长度：2-3 个单词

**示例**：
```
prd-desktop          # PRD 桌面客户端
visual-agent         # 视觉创作 Agent
literary-agent       # 文学创作 Agent
open-platform        # 开放平台
prd-admin            # 管理后台
```

**禁止**：
- ❌ `chat` - 太模糊，不知道是哪个应用的聊天
- ❌ `prd_desktop` - 使用下划线
- ❌ `PrdDesktop` - 使用驼峰
- ❌ `prd-desktop-application` - 太长

### 子功能代码（Feature Code）

**格式**：`kebab-case`（小写，短横线分隔）

**规则**：
- 使用英文，描述具体功能
- 体现功能的业务含义
- 长度：1-3 个单词

**示例**：
```
chat                 # 聊天对话
intent-recognition   # 意图识别
prd-analysis         # PRD 分析
image-generation     # 图片生成
content-generation   # 内容生成
chat-proxy           # 聊天代理
```

**禁止**：
- ❌ `sendMessage` - 使用驼峰
- ❌ `send_message` - 使用下划线
- ❌ `chatSendMessage` - 太技术化

### 完整调用标识（Call Identifier）

**格式**：`{app-code}.{feature-code}`

**示例**：
```
prd-desktop.chat                    # PRD Desktop 的聊天功能
prd-desktop.intent-recognition      # PRD Desktop 的意图识别
prd-desktop.prd-analysis            # PRD Desktop 的 PRD 分析
visual-agent.image-generation       # 视觉创作 Agent 的图片生成
visual-agent.image-analysis         # 视觉创作 Agent 的图片分析
literary-agent.content-generation   # 文学创作 Agent 的内容生成
literary-agent.illustration         # 文学创作 Agent 的配图生成
open-platform.chat-proxy            # 开放平台的聊天代理
open-platform.embedding-proxy       # 开放平台的向量嵌入代理
prd-admin.model-testing             # 管理后台的模型测试
```

## 系统内应用清单

### 1. PRD Desktop（prd-desktop）
**定位**：面向产品经理的桌面应用，提供 PRD 管理、AI 对话、Gap 分析等完整工作流

**子功能**：
| Feature Code | 中文名 | 模型需求 | 说明 |
|-------------|--------|---------|------|
| `chat` | 聊天对话 | chat | 用户与 AI 的日常对话 |
| `intent-recognition` | 意图识别 | intent | 快速识别用户消息意图 |
| `prd-analysis` | PRD 分析 | chat | 分析 PRD 文档内容 |
| `prd-preview` | PRD 预览问答 | chat | PRD 文档预览时的问答 |
| `gap-detection` | Gap 检测 | chat | 检测对话中的信息缺口 |
| `gap-summarization` | Gap 总结 | chat | 总结 Gap 内容 |

### 2. Visual Agent（visual-agent）
**定位**：独立的视觉内容创作系统，提供图片生成、分析、优化的完整流程

**子功能**：
| Feature Code | 中文名 | 模型需求 | 说明 |
|-------------|--------|---------|------|
| `image-generation` | 图片生成 | image-gen | 根据描述生成图片 |
| `image-analysis` | 图片分析 | vision | 分析图片内容 |
| `generation-verification` | 生成验证 | vision | 验证生成图片质量 |
| `creative-chat` | 创意对话 | chat | 与 AI 讨论创意想法 |

### 3. Literary Agent（literary-agent）
**定位**：独立的文学内容创作系统，提供故事生成、配图、润色的完整流程

**子功能**：
| Feature Code | 中文名 | 模型需求 | 说明 |
|-------------|--------|---------|------|
| `content-generation` | 内容生成 | chat | 生成文学内容 |
| `illustration` | 配图生成 | image-gen | 为内容生成配图 |
| `style-polishing` | 风格润色 | chat | 润色文学风格 |

### 4. Open Platform（open-platform）
**定位**：对外提供 API 服务的开放平台，代理 LLM 能力给第三方

**子功能**：
| Feature Code | 中文名 | 模型需求 | 说明 |
|-------------|--------|---------|------|
| `chat-proxy` | 聊天代理 | chat | 代理聊天 API |
| `embedding-proxy` | 向量嵌入代理 | embedding | 代理向量嵌入 API |
| `rerank-proxy` | 重排序代理 | rerank | 代理重排序 API |

### 5. PRD Admin（prd-admin）
**定位**：系统管理后台，提供配置、监控、测试等管理功能

**子功能**：
| Feature Code | 中文名 | 模型需求 | 说明 |
|-------------|--------|---------|------|
| `model-testing` | 模型测试 | chat | 测试模型能力 |
| `lab-experiments` | 实验室功能 | chat, vision, image-gen | 实验室多模型测试 |

## 代码中的约定

### 后端调用方式

```csharp
// 在业务代码中调用 LLM 时，必须传入完整的调用标识
var client = await _scheduler.GetClientAsync(
    appCallerCode: "prd-desktop.chat",  // 应用.子功能
    modelType: ModelTypes.Chat,
    cancellationToken: ct
);
```

### 前端调用方式

```typescript
// 前端调用 API 时，在请求头或参数中传入
const response = await fetch('/api/v1/chat/send', {
  headers: {
    'X-App-Caller': 'prd-desktop.chat',  // 应用.子功能
  },
  body: JSON.stringify({ message: '...' })
});
```

## 自动扫描原理

### 扫描机制

**原理**：从 LLM 调用日志中提取所有出现过的 `appCallerCode`，与已注册应用对比，发现未登记的。

**实现步骤**：
1. 查询 `llm_request_logs` 表，提取 distinct `app_caller_code`
2. 与 `llm_app_callers` 表对比，找出未注册的
3. 自动创建应用记录，标记为 `is_auto_registered: true`
4. 返回发现的应用列表供用户确认

**前置条件**：
- ✅ `LlmRequestLog` 模型需要添加 `AppCallerCode` 字段
- ✅ 业务代码需要改造成使用 `SmartModelScheduler`
- ✅ 所有 LLM 调用必须传入 `appCallerCode`

### 扫描的局限性

**能扫描到的**：
- ✅ 已经被调用过的子功能
- ✅ 有日志记录的子功能

**扫描不到的**：
- ❌ 新开发但未调用的子功能
- ❌ 日志被清理的历史子功能
- ❌ 代码中硬编码但未实际使用的标识

### 手动补充机制

**场景 1：新开发的子功能**
```
开发者在代码中新增了 `prd-desktop.document-export` 功能，
但还没有用户调用过，扫描无法发现。

解决方案：
1. 在管理后台点击"手动添加子功能"
2. 选择应用：prd-desktop
3. 输入子功能代码：document-export
4. 输入子功能名称：文档导出
5. 选择模型需求：chat
6. 保存
```

**场景 2：批量导入**
```
开发者可以提供一个 JSON 文件，批量导入应用和子功能：

{
  "app": "prd-desktop",
  "features": [
    {
      "code": "document-export",
      "name": "文档导出",
      "modelTypes": ["chat"]
    },
    {
      "code": "template-generation",
      "name": "模板生成",
      "modelTypes": ["chat"]
    }
  ]
}
```

**场景 3：代码注册（推荐）**
```csharp
// 在代码中使用静态常量定义，编译时检查
public static class AppCallers
{
    public static class PrdDesktop
    {
        public const string Chat = "prd-desktop.chat";
        public const string IntentRecognition = "prd-desktop.intent-recognition";
        public const string PrdAnalysis = "prd-desktop.prd-analysis";
        // ... 其他子功能
    }
}

// 使用时
var client = await _scheduler.GetClientAsync(
    appCallerCode: AppCallers.PrdDesktop.Chat,  // 类型安全
    modelType: ModelTypes.Chat,
    cancellationToken: ct
);

// 系统启动时自动注册
public static class AppCallerRegistry
{
    public static void RegisterAll()
    {
        // 通过反射扫描 AppCallers 类，自动注册所有常量
        var allCallers = typeof(AppCallers)
            .GetNestedTypes()
            .SelectMany(t => t.GetFields(BindingFlags.Public | BindingFlags.Static | BindingFlags.Constant))
            .Where(f => f.FieldType == typeof(string))
            .Select(f => (string)f.GetValue(null))
            .ToList();
        
        // 自动创建/更新应用记录
        foreach (var caller in allCallers)
        {
            // 解析 app-code.feature-code
            var parts = caller.Split('.');
            var appCode = parts[0];
            var featureCode = parts[1];
            
            // 创建或更新应用和子功能
            // ...
        }
    }
}
```

## 约定俗成的规则

### 规则 1：应用代码必须与项目名对应

| 项目/系统 | 应用代码 |
|----------|---------|
| prd-desktop（Tauri 桌面端） | `prd-desktop` |
| prd-admin（Web 管理后台） | `prd-admin` |
| prd-api（后端 API） | `prd-api` |
| 视觉创作 Agent | `visual-agent` |
| 文学创作 Agent | `literary-agent` |
| 开放平台 | `open-platform` |

### 规则 2：子功能代码必须体现业务含义

**好的命名**：
- ✅ `chat` - 清晰，聊天
- ✅ `prd-analysis` - 清晰，PRD 分析
- ✅ `image-generation` - 清晰，图片生成

**不好的命名**：
- ❌ `sendMessage` - 技术化，不体现业务
- ❌ `llmCall` - 太抽象
- ❌ `feature1` - 无意义

### 规则 3：调用标识必须在代码中定义为常量

**强制要求**：
```csharp
// ✅ 正确：使用常量
var client = await _scheduler.GetClientAsync(
    appCallerCode: AppCallers.PrdDesktop.Chat,
    modelType: ModelTypes.Chat,
    cancellationToken: ct
);

// ❌ 错误：硬编码字符串
var client = await _scheduler.GetClientAsync(
    appCallerCode: "prd-desktop.chat",  // 容易拼写错误
    modelType: ModelTypes.Chat,
    cancellationToken: ct
);
```

### 规则 4：新增子功能必须同步更新文档

**流程**：
1. 在代码中定义常量（`AppCallers.cs`）
2. 在本文档中更新应用清单表格
3. 在管理后台手动添加或等待自动扫描
4. 配置模型分组

## 检查清单

### 新增应用时

- [ ] 应用代码符合 `kebab-case` 规范
- [ ] 应用名称清晰体现业务定位
- [ ] 在本文档中添加应用清单
- [ ] 在代码中创建应用常量类
- [ ] 在管理后台初始化应用

### 新增子功能时

- [ ] 子功能代码符合 `kebab-case` 规范
- [ ] 子功能名称体现业务含义
- [ ] 在本文档中更新子功能表格
- [ ] 在代码中添加子功能常量
- [ ] 在管理后台添加子功能（手动或扫描）
- [ ] 配置模型需求和分组

## 常见问题

### Q1：如何判断是应用还是子功能？
**A**：问自己：这是一个独立的系统吗？如果是，就是应用；如果是应用内的一个功能点，就是子功能。

### Q2：子功能可以跨应用复用吗？
**A**：不可以。每个子功能必须隶属于一个应用。如果多个应用有相同的功能，应该分别定义（例如 `prd-desktop.chat` 和 `prd-admin.chat`）。

### Q3：扫描会漏掉新功能怎么办？
**A**：使用"手动添加子功能"或"批量导入"功能补充。推荐在代码中定义常量，系统启动时自动注册。

### Q4：应用代码可以修改吗？
**A**：不建议。应用代码是唯一标识，修改会导致历史数据无法关联。如果必须修改，需要同步更新所有代码和数据库。

### Q5：如何确保所有开发者遵守规范？
**A**：
1. 在代码审查中检查
2. 使用常量定义强制类型安全
3. 在 CI/CD 中添加检查脚本
4. 定期审查管理后台的应用列表

## 示例：添加新应用的完整流程

### 场景：新增"代码审查 Agent"

**步骤 1：确定应用代码**
```
应用名：Code Review Agent
应用代码：code-review-agent
```

**步骤 2：定义子功能**
```
- code-analysis：代码分析（需要 code 模型）
- bug-detection：Bug 检测（需要 code 模型）
- suggestion-generation：建议生成（需要 chat 模型）
```

**步骤 3：在代码中定义常量**
```csharp
public static class AppCallers
{
    public static class CodeReviewAgent
    {
        public const string CodeAnalysis = "code-review-agent.code-analysis";
        public const string BugDetection = "code-review-agent.bug-detection";
        public const string SuggestionGeneration = "code-review-agent.suggestion-generation";
    }
}
```

**步骤 4：更新本文档**
在"系统内应用清单"中添加：
```markdown
### 6. Code Review Agent（code-review-agent）
**定位**：独立的代码审查系统，提供代码分析、Bug 检测、建议生成的完整流程

**子功能**：
| Feature Code | 中文名 | 模型需求 | 说明 |
|-------------|--------|---------|------|
| `code-analysis` | 代码分析 | code | 分析代码结构和质量 |
| `bug-detection` | Bug 检测 | code | 检测潜在的 Bug |
| `suggestion-generation` | 建议生成 | chat | 生成改进建议 |
```

**步骤 5：在管理后台初始化**
1. 访问"模型管理" → "应用与分组"
2. 点击"初始化/同步应用"（如果已配置自动注册）
3. 或点击"手动添加应用"，填写应用信息

**步骤 6：配置模型分组**
1. 选择应用"Code Review Agent"
2. 为每个子功能配置模型分组
3. 保存配置

完成！现在可以在代码中使用 `AppCallers.CodeReviewAgent.CodeAnalysis` 调用 LLM 了。
